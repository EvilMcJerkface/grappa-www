<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Grappa: tutorial.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grappa
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tutorial.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="tutorial_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Grappa Tutorial</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;===============================================================================</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;This guide will <span class="keywordflow">try</span> to outline the key features of Grappa from an application<span class="stringliteral">&#39;s perspective at a high level. Detailed description of functionality is left out here; look at the generated Doxygen documentation for details.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="stringliteral">*Warning*: Grappa is a research project, and the programming interface for Grappa is still in flux. If you run a problem, please visit our GitHub questions page at https://github.com/uwsampa/grappa/issues?labels=question, where you may find a solution or ask for help.</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="stringliteral">Section 1: Hello World</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="stringliteral">-------------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="stringliteral">Topics in this section:</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="stringliteral">- global-view programming model</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="stringliteral">- what&#39;</span>s that in <a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>? (<a class="code" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">init</a>/<a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a>/<a class="code" href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380">finalize</a>)</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;- `<a class="code" href="group___collectives.html#gac74a2d7ffb5b36ec6833ebfc54c16841">on_all_cores</a>()`</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Here is the simplest possible Grappa program:</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;```cpp</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// tutorial/hello_world_1.cpp</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"></span><span class="preprocessor">#include &lt;<a class="code" href="_grappa_8hpp.html">Grappa.hpp</a>&gt;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="keywordtype">int</span> <a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  <a class="code" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">Grappa::init</a>(&amp;argc, &amp;argv);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">Grappa::run</a>([]{</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello world from the root task!\n&quot;</span>;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  });</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <a class="code" href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380">Grappa::finalize</a>();</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;```</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;When <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> with 4 <a class="code" href="group___communication.html#gaff2afcac6058e98ea3c6151f2445702b">cores</a> (2 nodes, with 2 processes per node) <span class="keyword">using</span> the Slurm launcher, we <span class="keyword">get</span> the following output:</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;```bash</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;&gt; make tutorial-hello_world_1</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;&gt; bin/grappa_srun --nnode=2 --ppn=2 -- tutorial/hello_world_1.exe</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;Hello world from the root task!</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;```</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;Grappa jobs, like MPI &amp; UPC, are launched with a separate process on each node in the job (known as SPMD -- Single Program Multiple <a class="code" href="struct_data.html">Data</a>). In <span class="keyword">this</span> <span class="keywordflow">case</span>, when Slurm launches the 2-node job, it executes `hello_world_1.exe` on both nodes. However, Grappa is primarily designed to be a <span class="stringliteral">&quot;global view&quot;</span> model, which means that rather than coordinating where all parallel SPMD processes are at and how they divide up the data, the programmer is encouraged to think of the system as a large single shared memory, use data structures that intelligently distribute themselves across the <a class="code" href="group___communication.html#gaff2afcac6058e98ea3c6151f2445702b">cores</a>, and <a class="code" href="group___delegates.html#ga13cb46277cd2bf8c03ae12952afdcaf4">write</a> parallel loops that <span class="keyword">get</span> executed in parallel across the whole machine. To that end, the body of the `<a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">Grappa::run</a>()` <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> spawns the <span class="stringliteral">&quot;root&quot;</span> task on a single core. This task determines the lifetime of the program: when it returns, the Grappa program ends. The intention is that <span class="keyword">this</span> task will <a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> many more tasks and synchronize with all of them and only <span class="keywordflow">return</span> when all of the work has been completed. Because it only runs once, the output is only printed once.</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;Breaking down the rest of what goes on in <a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>:</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;- `<a class="code" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">init</a>()`: parses command-line flags and environment variables, and then initializes all of Grappa<span class="stringliteral">&#39;s subsystems, such as the communication and threading systems, and global heap allocation.</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="stringliteral">- `run()`: starts the scheduling (tasking and communication) loop, and on Core 0 only spawns the main Grappa task. All cores stay inside this function until this main task returns, which immediately signals the others to exit the scheduling loop.</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="stringliteral">- `finalize()`: cleans up the process, closing communication channels and freeing memory; does not return.</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="stringliteral">### SPMD Variant</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="stringliteral">To further illustrate the global-view vs. SPMD models, we can add a bit of SPMD execution back into our Grappa program:</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="stringliteral">// tutorial/hello_world_2.cpp</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="stringliteral">#include &lt;Grappa.hpp&gt;</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="stringliteral">#include &lt;Collective.hpp&gt;</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="stringliteral">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="stringliteral">int main(int argc, char *argv[]) {</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="stringliteral">  Grappa::init(&amp;argc, &amp;argv);</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="stringliteral">  Grappa::run([]{</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="stringliteral">    std::cout &lt;&lt; &quot;Hello world from the root task!\n&quot;;</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="stringliteral">    Grappa::on_all_cores([]{</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="stringliteral">      std::cout &lt;&lt; &quot;Hello world from Core &quot; &lt;&lt; Grappa::mycore() &lt;&lt; &quot; of &quot; &lt;&lt; Grappa::cores()</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="stringliteral">                &lt;&lt; &quot; (locale &quot; &lt;&lt; Grappa::mylocale() &lt;&lt; &quot;)&quot;&lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="stringliteral">    });</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="stringliteral">    std::cout &lt;&lt; &quot;Exiting root task.\n&quot;;</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="stringliteral">  });</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="stringliteral">  Grappa::finalize();</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="stringliteral">This time when run on 4 cores, we may get output like this:</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="stringliteral">```bash</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="stringliteral">&gt; make tutorial-hello_world_2</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="stringliteral">&gt; bin/grappa_srun --nnode=2 --ppn=2 -- tutorial/hello_world_2.exe</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="stringliteral">Hello world from the root task!</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="stringliteral">Hello world from Core 1 of 4 (locale 0)</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="stringliteral">Hello world from Core 0 of 4 (locale 0)</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="stringliteral">Hello world from Core 3 of 4 (locale 1)</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="stringliteral">Hello world from Core 2 of 4 (locale 1)</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="stringliteral">Exiting root task.</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="stringliteral">This should look familiar to the MPI programmer. The call to `on_all_cores()` spawns a task on each core and then suspends the calling task (the root task in this case) until all those tasks have completed. Therefore, we do not see the &quot;Exiting&quot; message until after all of the &quot;Hello&quot;s, though those may arrive in any order. </span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="stringliteral">This also introduces the API for identifying cores. In Grappa, each core is a separate destination. The physical node on which a core resides is referred to as its &quot;locale&quot; (borrowed from Chapel&#39;</span>s terminology). The next section will refer to these functions more when dealing with how memory is partitioned among cores.</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;Section 2: Global memory</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;-------------------------------------------------------------------------------</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;In Grappa, all memory on all cores is addressable by any other core. This is done <span class="keyword">using</span> the `<a class="code" href="class_global_address.html">GlobalAddress&lt;T&gt;</a>` <span class="keyword">template</span> <span class="keyword">class</span>. In the spirit of other Partitioned Global Address Space (PGAS) languages and runtimes, Grappa provides mechanisms <span class="keywordflow">for</span> easily distributing data across the various memories of nodes in a cluster.</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;This section will:</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;- Describe global addressing, partitioning and the global heap</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;- Introduce the various ways of addressing and allocating global memory</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="preprocessor">### Global Addresses &amp; Allocators</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="preprocessor"></span>Global addresses fall into one of three different categories:</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;- **2D addresses**: can address any memory on a core, including memory on stacks of currently-executing tasks, or memory allocated <span class="keyword">using</span> `malloc` or `<span class="keyword">new</span>`</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;- **Linear addresses**: cyclicly partitioned among <a class="code" href="group___communication.html#gaff2afcac6058e98ea3c6151f2445702b">cores</a>, allocated from the global heap <span class="keyword">using</span> `global_alloc&lt;T&gt;()`, freed with `<a class="code" href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">global_free</a>()`</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;- **Symmetric addresses**: same address valid on all <a class="code" href="group___communication.html#gaff2afcac6058e98ea3c6151f2445702b">cores</a>, allocated from the global heap <span class="keyword">using</span> `symmetric_global_alloc&lt;T&gt;()`, freed with `<a class="code" href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">global_free</a>()`</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;Pretty much anywhere in the Grappa API that takes a <a class="code" href="class_global_address.html">GlobalAddress</a> will work with any of these types (they are all the same <span class="keyword">class</span>), but they will have different behavior in terms of how they map to cores.</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;#### 2D Addresses</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;The first, 2D addresses, are the simplest. They represent just the pairing of a pointer, and the <a class="code" href="_communicator_8hpp.html#a3a0af41b6e127e7f96781ce84aa9d40e">Core</a> where that pointer is valid. These can be created <span class="keyword">using</span> the <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> `<a class="code" href="group___memory.html#ga55c522130968fe1140cb8505dc9eac1a">make_global</a>()`, and will typically reference either data on a worker<span class="stringliteral">&#39;s execution stack, or something allocated from the core-private heap (using `new`). Consider the following example (note: the rest of `main()` has been left out, see the full source at `tutorial/addressing.cpp`):</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="stringliteral">long count = 0;</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="stringliteral">GlobalAddress&lt;long&gt; g_count = make_global( &amp;count );</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="stringliteral">LOG(INFO) &lt;&lt; &quot;global address -- valid on core:&quot; &lt;&lt; g_count.core() &lt;&lt; &quot;, pointer:&quot; &lt;&lt; g_count.pointer();</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="stringliteral">The call to `make_global()` creates a new global address with the given pointer to the `count` variable on this task&#39;</span>s stack and encodes the core where it is valid (`<a class="code" href="group___communication.html#ga9d165cbd8cbb54ce375f342722022a91">Grappa::mycore</a>()`) with it.</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="preprocessor">#### Linear addresses</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="preprocessor"></span>A portion of each node<span class="stringliteral">&#39;s global memory is set aside specifically for the *global heap*. This amount is determined by the command-line flag `--global_heap_fraction` (which defaults to 0.5). Allocations from this heap are distributed in a block-cyclic round-robin fashion across cores. Each core has a region of memory set aside for the global heap, with a heap offset pointer specific for the core. To allocate from this heap, the following functions are used:</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="stringliteral">- `GlobalAddress&lt;T&gt; Grappa::global_alloc&lt;T&gt;(size_t num_elements)`: allocates space for `num_elements` of size `T`, starting on some arbitrary core</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="stringliteral">- `void Grappa::global_free(GlobalAddress&lt;T&gt;)`: frees global heap allocation</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">*Linear* global addresses, returned by the global heap allocation function, are specifically designed for working with allocations from the global heap. Arithmetic on linear addresses will resolve to the correct core given the heap&#39;</span>s block <a class="code" href="_global_completion_event_8hpp.html#ad946b8f6f79a9ee73d674f86a7964100">size</a>, and on that core, will use the core<span class="stringliteral">&#39;s heap offset pointer to give the correct pointer to data.</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral">We will illustrate this with an example. Here we allocate an array of 48 elements, which, due to `block_size` being set to 64 bytes, allocates 8 to each core before moving on to the next core.</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral">auto array = global_alloc&lt;long&gt;(48);</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">for (auto i=0; i&lt;48; i++) {</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral">  std::cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;: core &quot; &lt;&lt; (array+i).core() &lt;&lt; &quot;] &quot;;</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral">std::cout &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral">```bash</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral">&gt; grappa_srun --nnode=2 --ppn=2 -- tutorial/addressing_linear.exe</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral">[0: core 0] [1: core 0] [2: core 0] [3: core 0] [4: core 0] [5: core 0] [6: core 0] [7: core 0]</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral">[8: core 1] [9: core 1] [10: core 1] [11: core 1] [12: core 1] [13: core 1] [14: core 1] [15: core 1]</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral">[16: core 2] [17: core 2] [18: core 2] [19: core 2] [20: core 2] [21: core 2] [22: core 2] [23: core 2]</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral">[24: core 3] [25: core 3] [26: core 3] [27: core 3] [28: core 3] [29: core 3] [30: core 3] [31: core 3]</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="stringliteral">[32: core 0] [33: core 0] [34: core 0] [35: core 0] [36: core 0] [37: core 0] [38: core 0] [39: core 0]</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="stringliteral">[40: core 1] [41: core 1] [42: core 1] [43: core 1] [44: core 1] [45: core 1] [46: core 1] [47: core 1]</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="stringliteral">#### Symmetric addresses</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral">Another kind of allocation that is possible is a &quot;symmetric&quot; allocation. This allocates a copy of the struct on each core from the global heap, returning a GlobalAddress that is valid (and has the same offset, hence &quot;symmetric&quot;) on every core. Symmetric global addresses are typically for data structures where it is desired to have something to refer to no matter which core one is on. *Due to limitations right now, you must pad the struct to be a multiple of the block size. This can be done using the macro: `GRAPPA_BLOCK_ALIGNED`*.</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="stringliteral">Below is an example of allocating a struct on all cores:</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="stringliteral">// tutorial/addressing_symmetric.cpp</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="stringliteral">#include &lt;Grappa.hpp&gt;</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="stringliteral">#include &lt;Collective.hpp&gt;</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="stringliteral">#include &lt;GlobalAllocator.hpp&gt;</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="stringliteral">using namespace Grappa;</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="stringliteral">struct Data {</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="stringliteral">  size_t N;</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="stringliteral">  long *buffer;</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="stringliteral">  void init(size_t N) {</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="stringliteral">    this-&gt;N = N;</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="stringliteral">    this-&gt;buffer = new long[32];</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="stringliteral">} GRAPPA_BLOCK_ALIGNED;</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="stringliteral">int main(int argc, char *argv[]) {</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="stringliteral">  init(&amp;argc, &amp;argv);</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="stringliteral">  run([]{    </span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="stringliteral">    // allocate a copy of Data on every core out of the global heap</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="stringliteral">    GlobalAddress&lt;Data&gt; d = symmetric_global_alloc&lt; Data &gt;();</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="stringliteral">    on_all_cores([d]{</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="stringliteral">      // use `-&gt;` overload to get pointer to local copy to call the method on</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="stringliteral">      d-&gt;init(1024);</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="stringliteral">    });</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="stringliteral">    // now we have a local copy of the struct available anywhere</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="stringliteral">    on_all_cores([d]{</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="stringliteral">      d-&gt;buffer[0] = d-&gt;N;</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="stringliteral">    });</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="stringliteral">  });</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="stringliteral">  finalize();</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="stringliteral">In this example, we want a copy of the Data struct on each core so tasks can access a local version no matter where they run. After calling `symmetric_global_alloc()` the structs have not been initialized, so we must call `init()` on each copy. Here we use the `-&gt;` operator overload for symmetric addresses to get the pointer to the local copy and call the method on it. Finally, we can now reference that allocated struct by just passing around the GlobalAddress to the symmetric allocation.</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="stringliteral">Section 3: Delegate operations</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="stringliteral">-------------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="stringliteral">One of the core tenets of Grappa&#39;</span>s programming model is the idea of *delegating* remote memory accesses to the core that owns the memory. By ensuring that only one core ever accesses each piece of memory, we can provide strong atomicity guarantees to Grappa programs that even single-node multithreaded applications typically <span class="keywordflow">do</span> not. It also allows us to more confidently play with the memory hierarchy to optimize <span class="keywordflow">for</span> low-locality access by careful management of caches and pre-fetching. Finally, delegating work to where the data is provides several advantages: it allows work to be distributed evenly across the machine and in some cases minimizes communication, provided the data is laid out well.</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;&lt;!-- (leaving out details about cooperative scheduling) For one thing, <span class="keyword">this</span> plays well with applications with low locality, as it allows work to be distributed evenly across the machine, provided the data is distributed well. It also plays a key role in providing a simple consistency model to programmers: due to Grappa<span class="stringliteral">&#39;s cooperative scheduling of tasks and communication within a core, atomicity is guaranteed between yield points (i.e. communication). --&gt;</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="stringliteral">If you want data that resides on another core, you will likely use a delegate operation of some sort to accomplish your work. Delegates send a request to another core and block the caller; eventually, the other core executes the request and sends a response which wakes the caller and may return a value. By blocking the caller and executing the delegate atomically, Grappa provides sequentially consistent access to distributed memory (more about this in some of our papers).</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="stringliteral">The most basic unit of delegates is `call()`, which has a couple different forms for convenience:</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="stringliteral">T call(Core dest, []() -&gt; T { /* (on &#39;</span>dest<span class="stringliteral">&#39;) */ })</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="stringliteral">U call(GlobalAddress&lt;T&gt; gp, [](T *p) -&gt; U { /* (on gp.core(), p = gp.pointer()) */ })</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="stringliteral">The provided lambda is executed on the specified core, blocking the caller. The return value of the lambda is returned to the caller when it is woken. The only restriction on code in the delegate is that is *must not suspend or yield to the scheduler*. This is to ensure that communication workers do not get stuck. An assertion will fail if this is violated. If you need to do blocking remotely, you can use `spawnRemote()` to create a task on the remote core, which will be able to do blocking operations. Alternatively, there is another form of `delegate::call` that takes a Mutex as an argument. See the Doxygen documentation for more details.</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="stringliteral">Some simple helper delegates for common operations are provided; they are implemented using the above generic delegates.</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="stringliteral">- `T read(GlobalAddress&lt;T&gt;)`: reads memory at that address</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="stringliteral">- `void write(GlobalAddress&lt;T&gt;, T val)`: writes a value into memory at that address</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="stringliteral">- `T fetch_and_add(GlobalAddress&lt;T&gt;, T inc)`: increments the value in memory and returns the previous value</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="stringliteral">- `bool compare_and_swap(GlobalAddress&lt;T&gt;, T cmp, T val)`: if value is equal to `cmp`, sets it to `val` and returns `true`, else returns `false`</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="stringliteral">Delegate operations have some template parameters that allow their behavior to be customized, such as making them &quot;asynchronous&quot;. This will be covered in the &quot;Intermediate&quot; part of the tutorial.</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="stringliteral">The following example demonstrates using delegates to access memory in the global heap, distributed among all the cores.</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="stringliteral">size_t N = 50;</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="stringliteral">GlobalAddress&lt;long&gt; array = global_alloc&lt;long&gt;(N);</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="stringliteral">// simple global write</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="stringliteral">for (size_t i = 0; i &lt; N; i++) {</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="stringliteral">  delegate::write( array+i, i );</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="stringliteral">for (size_t i = 0; i &lt; N; i += 10) {</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="stringliteral">  // boring remote read</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="stringliteral">  long value = delegate::read( array+i );</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="stringliteral">  std::cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; value;</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="stringliteral">  // do some arbitrary computation</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="stringliteral">  double v = delegate::call(array+i, [](long *a){ return tan(*a); });</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="stringliteral">  std::cout &lt;&lt; &quot;, tan = &quot; &lt;&lt; v &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="stringliteral">```bash</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="stringliteral">&gt; make tutorial-delegates &amp;&amp; bin/grappa_srun --nnode=2 --ppn=2 -- tutorial/delegates.exe</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="stringliteral">0: [0] = 0, tan = 0</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="stringliteral">0: [10] = 10, tan = 0.648361</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="stringliteral">0: [20] = 20, tan = 2.23716</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="stringliteral">0: [30] = 30, tan = -6.40533</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="stringliteral">0: [40] = 40, tan = -1.11721</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="stringliteral">This is still using the single root task to do all the work, so it is all still serial. The next section will cover how to spawn lots of parallel work efficiently.</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="stringliteral">Section 4: Tasking</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="stringliteral">-------------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="stringliteral">**Be aware:** Terminology about threading is very overloaded; everyone means something different when talking about them. In Grappa, we try to avoid using the term &quot;thread&quot;. Instead, we have *tasks* which are a (typically small) unit of work and *workers* which execute tasks. This is explained in more detail in this section.</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="stringliteral">The most basic unit of parallelism in Grappa is the *task*. A *task* is a unit of work that has some state and some code to run; this is typically specified using a C++11 *lambda*, but can also be specified with a more traditional C++ *functor* (a class with `operator()` overloaded). Tasks are not run immediately after they are created; instead, they go on a queue of un-started tasks.</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="stringliteral">*Workers* are lightweight user-level threads that are *cooperatively scheduled* (sometimes also known as *fibers*), which means that they run uninterrupted on a core until they choose to *yield* or *suspend*. A worker takes an un-started task off the queue, executes it to completion, suspending or yielding as the task specifies. When the task finishes (returns from the lambda/functor), the worker goes off to find another task to execute.</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="stringliteral">One of the benefits of our approach to multithreading is that within a Core, tasks and active messages are multiplexed on a single core, so only one will ever be running at a given time, and context switches happen only at known places: calls to synchronization and remote delegate operations. If, on the other hand, a region of code only references data local to a core, atomicity is guaranteed without any explicit synchronization needed.</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="stringliteral">### Bound/unbound tasks</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="stringliteral">By default, tasks are &quot;bound&quot; to the core they are created on. That is, they will stay on their local task queue until they are eventually picked up by a worker on that core. Tasks can also be spawned &quot;unbound&quot;, which puts them into a different queue. These tasks are load-balanced across all the cores in the cluster (using work-stealing). Therefore these &quot;unbound&quot; tasks have to handle being run from any core, and must be sure to fetch any additional data they need.</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="stringliteral">### Spawning tasks</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="stringliteral">The `spawn` command creates a new task and automatically adds it to the queue of tasks which Workers pull from:</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="stringliteral">// &#39;</span>bound<span class="stringliteral">&#39; task, will run on the same core</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="stringliteral">spawn([]{ /* task code */ });</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="stringliteral">// &#39;</span><a class="code" href="_grappa_8hpp.html#a8c30457bc353d908bcd82438bc27c9ef">unbound</a><span class="stringliteral">&#39; task, may be load-balanced to any core</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="stringliteral">spawn&lt;unbound&gt;([]{ /* task code */ });</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="stringliteral">### Task synchronization</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="stringliteral">Spawns happen &quot;asynchronously&quot;. That is, the task that called &quot;spawn&quot; continues right away, not waiting for the spawned task to get run. To ensure that a task has been executed before performing some operation, it must be synchronized with explicitly. </span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="stringliteral">Grappa provides a number of different options for synchronization, which we will cover more fully in a later section. Tasks may use any of the synchronization primitives directly, but here we will demonstrate just one way: using a `CompletionEvent`. Remember that the Grappa program terminates when the &quot;run&quot; task completes, so if that task does not block on spawned tasks completing, then they may not execute.</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="stringliteral">run([]{</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="stringliteral">  LOG(INFO) &lt;&lt; &quot;&#39;</span><a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a><span class="stringliteral">&#39; task started&quot;;</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="stringliteral">  CompletionEvent joiner;</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="stringliteral">  spawn(&amp;joiner, []{</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="stringliteral">    LOG(INFO) &lt;&lt; &quot;task ran on &quot; &lt;&lt; mycore();</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="stringliteral">  });</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="stringliteral">  spawn&lt;unbound&gt;(&amp;joiner, []{</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="stringliteral">    LOG(INFO) &lt;&lt; &quot;task ran on &quot; &lt;&lt; mycore();</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="stringliteral">  });</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="stringliteral">  joiner.wait();</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="stringliteral">  LOG(INFO) &lt;&lt; &quot;all tasks completed, exiting...&quot;;</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="stringliteral">Possible output:</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral">0: &#39;</span><a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a><span class="stringliteral">&#39; task started</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="stringliteral">1: task ran on 1</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="stringliteral">0: task ran on 0</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="stringliteral">0: all tasks completed, exiting</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="stringliteral">When the *main* task spawned the two other tasks, it passed in a pointer to the CompletionEvent it made. This caused &quot;spawn&quot; to enroll the tasks with the CompletionEvent, and causes them to automatically signal their &quot;completion&quot; when they finish. This allows the main task, after enrolling the two spawned tasks, to suspend, until the last enrolled task (could be either of them) signals completion, which then wakes the main task, and when the main task completes, this signals the Grappa program to come to an end.</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="stringliteral">### Parallel loops</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="stringliteral">Instead of spawning tasks individually, it&#39;</span>s almost always better to use a parallel loop of some sort. In addition to just looking better, these parallel loops also go to a significant amount of effort to <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> efficiently. For instance, they <a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> loop iterations recursively until hitting a threshold. This prevents over-filling the task buffers <span class="keywordflow">for</span> large loops, prevents excessive task overhead, and improves work-stealing by making it more likely that a single steal will generate significantly more work. They also spread out spawns across cores in the system, and when iterating over a region of linear global addresses, schedule the iterations to be as close to their data as possible.</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;The basic parallel loop is `<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>()`. The iteration range can be specified in a few different ways:</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;- `<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(startIndex, nIterations, [](int64_t i){ })`: Specify a start index and a number of iterations. The iterations will be split evenly across all the cores, broken up into evenly-sized blocks.</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;- `<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(address, nElements, [](T&amp; e){ })`: Specify a linear address (start of an allocation from the global heap, <span class="keywordflow">for</span> instance), and a number of elements. Iterations will be executed *at the core where the corresponding element lives*, and the lambda will be passed a simple reference to the element.</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;- `<a class="code" href="namespace_grappa_1_1impl.html#a3a32c8a9e7384af43f3ec125411d2f99">forall_here</a>(startIndex, nIterations, [](int64_t i){ })`: Like the above <a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>, except instead of spreading iterations across all cores, it spawns them all locally (though <span class="keywordflow">if</span> spawning <a class="code" href="_grappa_8hpp.html#a8c30457bc353d908bcd82438bc27c9ef">unbound</a> tasks, they may be moved).</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;Each `forall` loop accepts different forms of lambda, allowing <span class="keywordflow">for</span> a bit more control. For instance, a `forall` over elements in an array of `<span class="keywordtype">double</span>`s could be invoked:</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;```cpp</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">// just a reference to the element</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(array, 100, [](<span class="keywordtype">double</span>&amp; e){ <span class="comment">/* ... */</span> });</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">// reference + the absolute index of the element</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(array, 100, [](int64_t i, <span class="keywordtype">double</span>&amp; e){ <span class="comment">/* ... */</span> });</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">// a range of &#39;n&#39; iterations, starting with &#39;start&#39;, and a pointer to the first one.</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">// (not often used outside of library implementations)</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(array, 100, [](int64_t start, int64_t n, <span class="keywordtype">double</span> * e){ <span class="comment">/* ... */</span> });</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;```</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;Finally, each of the parallel loops allows specifying <span class="keyword">template</span> parameters which affect how they <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a>. The most notable of which are:</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;- <a class="code" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> (Bound/Unbound): Just as `<a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a>` can optionally <a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> <span class="stringliteral">&quot;unbound&quot;</span> tasks which are load-balanced, parallel loops take the same parameter and use it when spawning tasks.</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;- <a class="code" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> (<a class="code" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7aabd0ca6be53b0f3d2886fd53fcb52574e">Blocking</a>/<a class="code" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7aa24aa4117da86c41684ad25742832dfa6">Async</a>): By default, loops block the caller until <a class="code" href="group___synchronization.html#gad0f5511c9e55d6d5cd3add33bf00d527">complete</a>, but one can specify <span class="stringliteral">&quot;async&quot;</span> to make the <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> non-blocking. Most parallel loops use a GlobalCompletionEvent for synchronization. To ensure all <span class="stringliteral">&quot;async&quot;</span> loops have <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a>, a task can <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> `<a class="code" href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">wait</a>` on the GlobalCompletionEvent used for the loop (specified by another template parameter). By default, all `forall`s use the same GCE, so best practice is to use `<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>` inside of an outer blocking `forall` (or a <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> to `<a class="code" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">finish</a>()`), which will ensure all the inner asyncs have finished before continuing.</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;- Threshold: This specifies how many iterations are <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> serially by a single task. Parallel loops recursively <a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> tasks to split the iterations evenly, and stop recursing only when reaching this Threshold. By default, loops use the command-line flag `--parallel_loop_threshold`, but a different threshold can be specified statically if needed (for instance, if you want to ensure that each iteration gets its own task, you would specify Threshold=1).</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;- GlobalCompletionEvent: this parameter statically specifies a GCE to use for synchronizing the iterations of the loop. Change this only if you cannot use the default GCE for some reason (e.g. you are already using the default GCE concurrently in another context).</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;Because of a bunch of overloaded declarations, these template parameters can be specified in roughly any order, with the rest being left as default. So each of these is valid: `forall&lt;<a class="code" href="_grappa_8hpp.html#a8c30457bc353d908bcd82438bc27c9ef">unbound</a>&gt;`, `forall&lt;<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>&gt;`, `forall&lt;<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>,<a class="code" href="_grappa_8hpp.html#a8c30457bc353d908bcd82438bc27c9ef">unbound</a>&gt;`, `forall&lt;<a class="code" href="_grappa_8hpp.html#a8c30457bc353d908bcd82438bc27c9ef">unbound</a>,<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>,1&gt;`, `forall&lt;&amp;my_gce&gt;`, ...</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;Section 5: Bringing it all together with GUPS</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;-------------------------------------------------------------------------------</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;We will use a simple benchmark to illustrate the use of parallel loops and delegate operations. <span class="stringliteral">&quot;GUPS&quot;</span>, which stands for <span class="stringliteral">&quot;Giga-Updates Per Second&quot;</span> is a measure and a benchmark for random access rate. The basic premise is to see how quickly you can issue updates to a global array, but the updates are indexed by another array.</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;```cpp</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">// applications/demos/gups/gups.cpp</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">// make -j TARGET=gups4.exe mpi_run GARGS=&quot; --sizeB=$(( 1 &lt;&lt; 28 )) --loop_threshold=1024&quot; PPN=8 NNODE=12</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;#include &lt;Grappa.hpp&gt;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;using namespace Grappa;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">// define command-line flags (third-party &#39;gflags&#39; library)</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<a class="code" href="_aggregator_8cpp.html#a20f1ffc9506ce3245f5e40eed824724b">DEFINE_int64</a>( sizeA, 1 &lt;&lt; 30, <span class="stringliteral">&quot;Size of array that GUPS increments&quot;</span> );</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<a class="code" href="_aggregator_8cpp.html#a20f1ffc9506ce3245f5e40eed824724b">DEFINE_int64</a>( sizeB, 1 &lt;&lt; 20, <span class="stringliteral">&quot;Number of iterations&quot;</span> );</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">// define custom statistics which are logged by the runtime</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">// (here we&#39;re not using these features, just printing them ourselves)</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<a class="code" href="group___utility.html#gaca7bf381c18a5f791155eb129c726fe7">GRAPPA_DEFINE_METRIC</a>( SimpleMetric&lt;double&gt;, gups_runtime, 0.0 );</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<a class="code" href="group___utility.html#gaca7bf381c18a5f791155eb129c726fe7">GRAPPA_DEFINE_METRIC</a>( SimpleMetric&lt;double&gt;, gups_throughput, 0.0 );</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="keywordtype">int</span> <a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[]) {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <a class="code" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">init</a>( &amp;argc, &amp;argv );</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a>([]{</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="comment">// allocate target array from the global heap</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keyword">auto</span> A = global_alloc&lt;int64_t&gt;(FLAGS_sizeA);</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="comment">// fill the array with all 0&#39;s (happens in parallel on all cores)</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <a class="code" href="group___containers.html#gac5a9df86f535f81420219d9dfcab5584">Grappa::memset</a>( A, 0, FLAGS_sizeA );</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    </div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="comment">// allocate another array</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keyword">auto</span> B = global_alloc&lt;int64_t&gt;(FLAGS_sizeB);</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="comment">// initialize the array with random indices </span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>( B, FLAGS_sizeB, [](int64_t&amp; b) {</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      b = random() % FLAGS_sizeA;</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    });</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="keywordtype">double</span> start = <a class="code" href="namespace_grappa.html#a10cafc5a51b1eefe09225ca90dd79efb">walltime</a>();</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="comment">// GUPS algorithm:</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="comment">// for (int i = 0; i &lt; sizeB; i++) {</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="comment">//   A[B[i]] += 1;</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="comment">// }</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    gups_runtime = <a class="code" href="namespace_grappa.html#a10cafc5a51b1eefe09225ca90dd79efb">walltime</a>() - start;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    gups_throughput = FLAGS_sizeB / gups_runtime;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    LOG(INFO) &lt;&lt; gups_throughput.value() &lt;&lt; <span class="stringliteral">&quot; UPS in &quot;</span> &lt;&lt; gups_runtime.value() &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span>;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    </div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <a class="code" href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">global_free</a>(B);</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <a class="code" href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">global_free</a>(A);</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    </div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  });</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <a class="code" href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380">finalize</a>();</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;}</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;```</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;Here we<span class="stringliteral">&#39;ve setup the GUPS benchmark, but left out the main loop that does the updates. We first initialized Grappa, then `run` the main task. This task will allocate two arrays from the global heap: A, which is the array we&#39;</span>ll update, and B, which we fill with random numbers which will index into the A array. Next, we will step through a couple different implementations of the <a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a> GUPS loop to demonstrate the features we<span class="stringliteral">&#39;ve discussed so far.</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="stringliteral">### Simple `forall`</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="stringliteral">// applications/demos/gups/gups1.cpp</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="stringliteral">forall(0, FLAGS_sizeB, [=](int64_t i){</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="stringliteral">  delegate::fetch_and_add( A + delegate::read(B+i), 1);</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral">This implementation uses the form of `forall` that takes a start index and a number of iterations. Then we specify with a lambda what to do with each iteration, knowing that the parallel loop will instantiate tasks on all the cores to execute the iterations. Note how we&#39;</span>re <span class="keyword">using</span> the implicit capture-by-value form of lambda (`[=]`). This means that copies of the GlobalAddresses `A` and `B` will be used in the tasks.</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;We use the simplest delegate operation: `<a class="code" href="group___delegates.html#ga3e28e8fd8f1a8a22beca2301cb24a639">read</a>` to load the random <a class="code" href="_global_completion_event_8hpp.html#a3525a4b506b239918f69d5880f19638a">target</a> index from the B array, and then we use another helper delegate `<a class="code" href="group___delegates.html#gac416433d8fcb845ba67ef1f3509c1a45">fetch_and_add</a>` to <a class="code" href="group___delegates.html#gacad9d4d47cb0c49667bfdd59c604c100">increment</a> the indicated element in A. </div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;A minor variant of the above implementation could use `forall&lt;unbound&gt;()` instead, which would allow iterations to be load-balanced, so that <span class="keywordflow">if</span> random variation caused some iterations to take longer, other cores could help out by taking some work themselves.</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;### Localized `forall`</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;The previous implementation is inefficient in one glaringly obvious way: iterations are scheduled blindly onto cores, without considering what data they will touch. We happen to be iterating consecutively over all the elements in the `B` array. We don<span class="stringliteral">&#39;t know where each iteration will run, so we must do a remote `read` to fetch `B[i]`. Instead, we could use another form of `forall` to tell the runtime to schedule iterations to line up with elements in the B array:</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="stringliteral">// applications/demos/gups/gups2.cpp</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="stringliteral">forall(B, FLAGS_sizeB, [=](int64_t&amp; b){</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="stringliteral">  delegate::fetch_and_add( A + b, 1 );</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="stringliteral">In this version, we no longer need to do a remote reference to get an element of `B`, each iteration gets a reference to one automatically. We then just do the one remote delegate call to increment that random element in `A`, wherever it is.</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="stringliteral">### Asynchronous delegates</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="stringliteral">Another wasteful practice in the previous implementations is in using a blocking `delegate::fetch_and_add` to increment the remote value. As indicated by the name, `fetch_and_add` doesn&#39;</span>t just <a class="code" href="group___delegates.html#gacad9d4d47cb0c49667bfdd59c604c100">increment</a>, it also returns the previous value to the caller, which we then promptly ignore. We could save that <span class="keywordflow">return</span> trip, and all the nuisance of suspending and waking the calling task, <span class="keywordflow">if</span> we invoked a delegate operation that just did the increment asynchronously. Luckily such a <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> exists:</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;```cpp</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment">// applications/demos/gups/gups3.cpp</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;forall(B, FLAGS_sizeB, [=](int64_t&amp; b){</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  delegate::increment&lt;async&gt;( A + b, 1);</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;});</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;```</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;This `<a class="code" href="group___delegates.html#gacad9d4d47cb0c49667bfdd59c604c100">delegate::increment</a>()` does *not* <span class="keywordflow">return</span> the resulting value, which means we can <a class="code" href="namespace_grappa.html#a71018ba89353f75b1a4159b95295b801">invoke</a> the `<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>` version of it, <span class="keyword">using</span> the <span class="keyword">template</span> parameter. This means we issue the increment delegate, and immediately go on to <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> the next iteration. To ensure all these updates <a class="code" href="group___synchronization.html#gad0f5511c9e55d6d5cd3add33bf00d527">complete</a> before continuing, we must synchronize with these <a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a> delegates. By <span class="keywordflow">default</span>, specifying `&lt;<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>&gt;` enrolls the delegate with the <span class="keywordflow">default</span> GlobalCompletionEvent, which is the same GCE that `forall` uses to synchronize itself, so <span class="keyword">this</span> <span class="stringliteral">&quot;magically&quot;</span> means that the enclosing `forall` waits until all increments have completed before waking the *<a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>* task it was called from.</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  </div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;This <span class="keyword">final</span> version of GUPS is doing an amortized single <a class="code" href="group___communication.html#ga1b0faf3e8ee3ef69117c14c5d4547396">message</a> per iteration (it takes some messages to setup the parallel loops on all cores, and some combined completion messages to detect when the increments are all completed), which is about as good as we can <span class="keywordflow">do</span>. The rest is up to the Grappa runtime to perform these messages as efficiently as possible.</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;### Custom delegate operations</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;Just as an aside, we <span class="stringliteral">&quot;lucked out&quot;</span> in our GUPS implementations above in that we had already had a delegate operation to <span class="keywordflow">do</span> the increment. If, instead, GUPS called <span class="keywordflow">for</span> some other arbitrary operation, it would actually be nearly as simple to implement that just <span class="keyword">using</span> the <span class="keyword">generic</span> `<a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">delegate::call</a>()`:</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;```cpp</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">// applications/demos/gups/gups4.cpp</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(B, FLAGS_sizeB, [=](int64_t i, int64_t&amp; b){</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  <span class="keyword">auto</span> addr = A + b;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  delegate::call&lt;async&gt;(addr.core(), [addr, i] {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    *(addr.pointer()) ^= i;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  });</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;});</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;```</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;Here, we use the index in the B array to xor the existing value in A. We compute the address of the element (`addr`), then use it to tell `<a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a>` which core to <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> on (remember because `A` is a linear address, the elements are automatically striped across cores). Finally, on the correct core, we ask `addr` <span class="keywordflow">for</span> the local pointer, and use it to update the value. Like `<a class="code" href="group___delegates.html#gacad9d4d47cb0c49667bfdd59c604c100">delegate::increment</a>`, `<a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">delegate::call</a>` can be made <span class="stringliteral">&quot;async&quot;</span> in the same way, and it uses the <span class="keywordflow">default</span> GCE, too, so we know that all of these will be <a class="code" href="group___synchronization.html#gad0f5511c9e55d6d5cd3add33bf00d527">complete</a> when the `forall` returns.</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;Because it is common to <span class="keywordflow">do</span> delegates on a single <a class="code" href="class_global_address.html">GlobalAddress</a>, we have an alternate form of `<a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a>` that takes a GlobalAddress, gets the `core()` from it, and then passes the `pointer()` to the provided lambda. Using <span class="keyword">this</span> version simplifies the implementation nicely:</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;```cpp</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<a class="code" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a>(B, FLAGS_sizeB, [=](int64_t i, int64_t&amp; b){</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  delegate::call&lt;async&gt;(A+b, [i](int64_t* a){ *a ^= i; });</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;});</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;```</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;Section 6: Nested dynamic parallelism</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;-------------------------------------------------------------------------------</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;We will use a tree <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a> to illustrate the spawning and syncing of an unpredictable</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;number of dynamic tasks.</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;Let<span class="stringliteral">&#39;s start with an example problem: We have a tree in global memory. Each node has an id, a color value (0-10), and pointers to its children. The goal of this first version is traverse the tree and count the number of vertices with a given color.</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral">For the sake of brevity, we&#39;</span>ve hidden away the code to generate the random tree in `tree.hpp`, and instead just <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> `<a class="code" href="tree_8hpp.html#aca24a3c0ef851eaa0da0cd75cde76eab">create_tree</a>()`, which returns a GlobalAddress to the root node.</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;In order to keep a <a class="code" href="search1_8cpp.html#a9139bae75747a04b3bf2c3e7cfd10bc2">count</a> of matches found, we<span class="stringliteral">&#39;re using a little trick: we declare a `count` variable in the top-level namespace. Remember that Grappa programs are run &quot;SPMD&quot; like MPI programs, so each of these top-level variables are available (and separate) on each core. So, in our `on_all_cores()`, we initialize the count to 0, and set the search color (this saves us from having to pass the color around to each task).</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="stringliteral">int64_t count;</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="stringliteral">long search_color;</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="stringliteral">GlobalCompletionEvent gce;</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="stringliteral">int main( int argc, char * argv[] ) {</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="stringliteral">  init( &amp;argc, &amp;argv );</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="stringliteral">  run([]{</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="stringliteral">    size_t num_vertices = 1000;</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="stringliteral">    GlobalAddress&lt;Vertex&gt; root = create_tree(num_vertices);</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="stringliteral">    // initialize all cores</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="stringliteral">    on_all_cores([]{</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="stringliteral">      search_color = 7; // arbitrary search</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="stringliteral">      count = 0;</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="stringliteral">    });</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="stringliteral">    finish&lt;&amp;gce&gt;([=]{</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="stringliteral">      search( root );</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="stringliteral">    });</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="stringliteral">    // compute total count</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="stringliteral">    int64_t total = reduce&lt;int64_t,collective_add&lt;int64_t&gt;&gt;(&amp;count);</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="stringliteral">    LOG(INFO) &lt;&lt; &quot;total count: &quot; &lt;&lt; total;</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="stringliteral">  });</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="stringliteral">  finalize();</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="stringliteral">  return 0;</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="stringliteral">We will delve into the workings of the `finish` block that calls `search` recursively next. First, however, let&#39;</span>s jump over that and look at what we <span class="keywordflow">do</span> after. In the course of the <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a>, we will increment the various copies of `<a class="code" href="search1_8cpp.html#a9139bae75747a04b3bf2c3e7cfd10bc2">count</a>` found on each core. To compute the total <a class="code" href="search1_8cpp.html#a9139bae75747a04b3bf2c3e7cfd10bc2">count</a>, we have to sum up all of them, so we need to <a class="code" href="namespace_grappa.html#a71018ba89353f75b1a4159b95295b801">invoke</a> a *Collective* operation. Here we are <span class="keyword">using</span> a `<a class="code" href="group___collectives.html#ga11c2394bdfc6a31779ddc418cf790b73">reduce</a>`, which is called from one task (`<a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>` typically), and takes a pointer to a top-level variable. It retrieves the value at that pointer from each core and applies the reduction operation specified by the <span class="keyword">template</span> parameter. In <span class="keyword">this</span> <span class="keywordflow">case</span>, that is `<a class="code" href="_collective_8hpp.html#a230e982687661a48480a16098f36e533">collective_add</a>`. After all the <a class="code" href="search2_8cpp.html#ac9e7613948b8bd919d4205d430183a00">results</a> have been summed up, it returns the total value to `<a class="code" href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>`.</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;More of these operations and other ways to <a class="code" href="namespace_grappa.html#a71018ba89353f75b1a4159b95295b801">invoke</a> collectives can be found under the `Collectives` tab in the Doxygen documentation, or in `Collectives.hpp` in the source.</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;Now we<span class="stringliteral">&#39;ll explain the workings of the `finish` block and the search. But first we must introduce GlobalCompletionEvent a bit more fully that we have so far.</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="stringliteral">### GlobalCompletionEvent</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="stringliteral">Up to now, we&#39;</span>ve treated the GlobalCompletionEvent as a magical way to ensure that everything inside a loop runs before the loop finishes. The truth is, GCE is a very finicky bit of synchronization that allows us to efficiently track many outstanding asynchronous events that may happen on any core in the system and may migrate. GCE implements a <span class="stringliteral">&quot;termination detection&quot;</span> algorithm so we can <a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> tasks dynamically and still ensure that all of them have completed; we don<span class="stringliteral">&#39;t have to specify the total number of tasks ahead of time. In addition, to make it efficient, the GCE saves communication by combining multiple &quot;completion&quot; events into a single one.</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="stringliteral">The downside is that in order to implement these features, GCE&#39;</span>s are rather tricky to use. Task spawns, asynchronous delegates, and parallel loops all use the GCE to synchronize. We specify the GCE statically, which means it cannot be created dynamically---it must be declared as a top-level variable, as in the code example above (`<a class="code" href="search1_8cpp.html#adeea7b0e098ad4d29e4c12c41cb73e43">gce</a>`). It also means that `<a class="code" href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">wait</a>` calls cannot be nested: a <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> to <a class="code" href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">wait</a> will no awake until all tasks enrolled with the GCE on all cores have completed, so <span class="keywordflow">if</span> the task which calls <a class="code" href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">wait</a> is enrolled, it will deadlock.</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;The best practice with GCE<span class="stringliteral">&#39;s is usually to use the default GCE which is specified as a default template parameter for these calls, and then ensure that only the original `main` task blocks on it. This is what we did in the GUPS examples above.</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="stringliteral">In our new tree search example, we don&#39;</span>t have a top-level parallel loop. Instead, we start with a recursive <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> to `search`. Therefore, we use a <span class="keyword">new</span> <span class="keyword">function</span>, `<a class="code" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">finish</a>()`. This does nothing more than execute the enclosing lambda, and then <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> `<a class="code" href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">wait</a>()` on the given GCE. The name harkens to the <a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>/<a class="code" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">finish</a>-style parallelism espoused by X10 and Habaero Java. Our version is not nearly as sophisticated: it cannot be nested, and enclosing asynchronous calls must ensure that they use the same GCE (<span class="keywordflow">if</span> <span class="keyword">using</span> the <span class="keywordflow">default</span>, <span class="keyword">this</span> is easy).</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;```cpp</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;finish&lt;&amp;gce&gt;([=]{</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a>( root );</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;});</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;```</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;Our `search` <span class="keyword">function</span>, which we will show next, recursively creates tasks, enrolling each of them with the same GCE, so that we are guaranteed to have traversed the entire tree before the enclosing `<a class="code" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">finish</a>` completes. These tasks, though nested in the sense of our recursive `search` calls, are not recursively joining, but rather they all join at the one `<a class="code" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">finish</a>` <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a>.</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;```cpp</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="keywordtype">void</span> <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a>(<a class="code" href="class_global_address.html">GlobalAddress&lt;Vertex&gt;</a> vertex_addr) {</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="comment">// fetch the vertex info</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <a class="code" href="struct_vertex.html">Vertex</a> v = <a class="code" href="group___delegates.html#ga3e28e8fd8f1a8a22beca2301cb24a639">delegate::read</a>(vertex_addr);</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  </div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  <span class="comment">// check the color</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  <span class="keywordflow">if</span> (v.<a class="code" href="struct_vertex.html#a05cd99acff53a6e8eced70cf58c93424">color</a> == <a class="code" href="search1_8cpp.html#acf3ae97c6a67edaad03d52ba3bb2aba4">search_color</a>) count++;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  </div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  <span class="comment">// search children</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;  <a class="code" href="class_global_address.html">GlobalAddress&lt;Vertex&gt;</a> children = v.<a class="code" href="struct_vertex.html#a701b309f0cf071ab3169295906a00b34">first_child</a>;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  forall_here&lt;unbound,async,&amp;gce&gt;(0, v.<a class="code" href="struct_vertex.html#a559eab86c75e9f09d2a43a66621299e0">num_children</a>, [children](int64_t i){</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a>(children+i);</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  });</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;}</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;```</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;The <span class="keyword">function</span> above takes a GlobalAddress to a vertex and immediately fetches it into a local variable. This involves copying each of the <span class="keyword">struct </span>members into the local <a class="code" href="struct_vertex.html">Vertex</a> instance. It<span class="stringliteral">&#39;s not very much data, just the ID, color, number of children, and a pointer to the children. The reason we have to do this fetch is that once we start doing recursive calls, we don&#39;</span>t know which core <span class="keyword">this</span> will be <a class="code" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> on. Once we<span class="stringliteral">&#39;ve copied the Vertex data, we check the color, and potentially count the vertex. Then we grab the GlobalAddress pointing to the first child of this vertex, and spawn tasks to search each child using `forall_here`. We&#39;</span>ve chosen to <a class="code" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> <span class="stringliteral">&quot;unbound&quot;</span> tasks so they can be load balanced, and remember we have to specify `<a class="code" href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a>`, otherwise we would be nesting calls to `<a class="code" href="search1_8cpp.html#adeea7b0e098ad4d29e4c12c41cb73e43">gce</a>.wait()`.</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;### Alternative delegate</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;If <a class="code" href="struct_vertex.html">Vertex</a> was a bit larger and more unwieldy, we might instead choose to <span class="keywordflow">do</span> a delegate <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> to save some data movement. For instance, we could <span class="keywordflow">do</span>:</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;```cpp</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="keywordtype">void</span> <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a>(<a class="code" href="class_global_address.html">GlobalAddress&lt;Vertex&gt;</a> vertex_addr) {</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  <span class="keyword">auto</span> pair = <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">delegate::call</a>(vertex_addr, [](<a class="code" href="struct_vertex.html">Vertex</a> * v){</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    <span class="keywordflow">if</span> (v-&gt;<a class="code" href="struct_vertex.html#a05cd99acff53a6e8eced70cf58c93424">color</a> == <a class="code" href="search1_8cpp.html#acf3ae97c6a67edaad03d52ba3bb2aba4">search_color</a>) count++;</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <span class="keywordflow">return</span> make_pair(v-&gt;<a class="code" href="struct_vertex.html#a701b309f0cf071ab3169295906a00b34">first_child</a>, v-&gt;<a class="code" href="struct_vertex.html#a559eab86c75e9f09d2a43a66621299e0">num_children</a>);</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  });</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  </div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  <span class="keyword">auto</span> children = pair.first;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  forall_here&lt;unbound,async,&amp;gce&gt;(0, pair.second, [children](int64_t i){</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <a class="code" href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a>(children+i);</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  });</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;}</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;```</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;The advantage of <span class="keyword">this</span> is that we end up only moving half of the `<a class="code" href="struct_vertex.html">Vertex</a>`. As an aside, we can<span class="stringliteral">&#39;t do the `forall_here` inside the delegate because it requires doing a potentially-blocking call to enroll tasks with the GCE.</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral">### Use a GlobalVector to save the results</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral">What if, instead of just counting the matches, we actually wanted to keep a list of them? Grappa provides a few simple data structures for cases such as this. They all work in a similar fashion, so this next example will demonstrate some of the quirks of how to use these highly useful data structures.</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral">A GlobalVector is a wrapper around a global heap allocation (the underlying array), which allows tasks on any core to access, push, or pop elements, all safely synchronized and optimized for high throughput with lots of concurrent accessors. The way this is accomplished is by allocating a &quot;proxy&quot; structure on each core which will service requests in parallel on each core, and combine them into bulk requests, which are more efficient.</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral">This time, in `main`, instead of initializing `count` to 0, we create the GlobalVector that will hold vertex indices:</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral">```cpp</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral">GlobalAddress&lt;GlobalVector&lt;index_t&gt;&gt; rv = GlobalVector&lt;index_t&gt;::create(num_vertices);</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral">// initialize all cores</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral">on_all_cores([=]{</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral">  search_color = 7; // arbitrary search</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral">  results = rv;</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral">We have to use the static `create` method rather than calling `new` because it actually allocates space on each core, initializes them all, and returns a **symmetric** GlobalAddress that resolves to the proxy on each core. We then use the same top-level variable trick as with `search_color` to make this GlobalAddress available to all of the cores.</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral">Now in search, we do all the same things, except this time, if the color matches, we use the symmetric address `results` in a way we haven&#39;</span>t seen yet:</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;```cpp</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment">// -- inside search() function, see the rest in tutorial/search2.cpp</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="keywordflow">if</span> (v.<a class="code" href="struct_vertex.html#a05cd99acff53a6e8eced70cf58c93424">color</a> == <a class="code" href="search1_8cpp.html#acf3ae97c6a67edaad03d52ba3bb2aba4">search_color</a>) {</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  <span class="comment">// save the id to the results vector</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  <a class="code" href="search2_8cpp.html#ac9e7613948b8bd919d4205d430183a00">results</a>-&gt;push( v.<a class="code" href="struct_vertex.html#ab0e93fe247b5054a22ef04c5e754ea32">id</a> );</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;}</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;```</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;The member dereference operator (`operator-&gt;()`) has been overloaded <span class="keywordflow">for</span> GlobalAddress to <span class="keyword">get</span> at the pointer <span class="keywordflow">for</span> the current core. In order <span class="keywordflow">for</span> <span class="keyword">this</span> to work correctly, it has to be called *on the core where it is valid*. In the <span class="keywordflow">case</span> of symmetric GlobalAddresses like <span class="keyword">this</span> one, it is valid to <span class="keywordflow">do</span> <span class="keyword">this</span> on any core, but *it must be called on the core it is used on*. You must be careful not to extract the pointer and then pass that around, as some computation has to be done by GlobalAddress to resolve the address differently on each core. With that overloaded <span class="keyword">operator</span>, it is then easy to <a class="code" href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">call</a> GlobalVector<span class="stringliteral">&#39;s `push` method with the current vertex id. This blocks until the `push` has finished, just like other delegate operations.</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral">Section 7: Further reading</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral">-------------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral">For more on Grappa&#39;</span>s design decisions, see our papers, available from the Grappa webiste.</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;To find out more about Grappa<span class="stringliteral">&#39;s API, take a look at the autogenerated API docs. `BUILD.md` discusses building them for yourself, or you can examine the copy on the Grappa website. </span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral">Finally, here are some good examples in the repo:</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral">- `system/New_loop_tests.cpp`</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral">- `system/New_delegate_tests.cpp`</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral">- `system/CompletionEvent_tests.cpp`</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral">- `system/Collective_tests.cpp`</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral">- `applications/graph500/grappa/{main_new,bfs_local_adj,cc_new}.cpp`</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral">- `applications/NPB/GRAPPA/IS/intsort.cpp`</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral">- `applications/suite/grappa/{centrality.cpp,main.cpp}`</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral">- `applications/pagerank/pagerank.cpp`</span></div>
<div class="ttc" id="search1_8cpp_html_a02a63a33829d9b2f7a6375259af47fe9"><div class="ttname"><a href="search1_8cpp.html#a02a63a33829d9b2f7a6375259af47fe9">search</a></div><div class="ttdeci">void search(GlobalAddress&lt; Vertex &gt; vertex_addr)</div><div class="ttdef"><b>Definition:</b> <a href="search1_8cpp_source.html#l00009">search1.cpp:9</a></div></div>
<div class="ttc" id="_grappa_8hpp_html_ada84521eeb4bb9ac422d21429806aff3"><div class="ttname"><a href="_grappa_8hpp.html#ada84521eeb4bb9ac422d21429806aff3">async</a></div><div class="ttdeci">#define async</div><div class="ttdoc">Specify non-blocking operation (to be used in loops, delegates, etc) </div><div class="ttdef"><b>Definition:</b> <a href="_grappa_8hpp_source.html#l00091">Grappa.hpp:91</a></div></div>
<div class="ttc" id="namespace_grappa_html_a10cafc5a51b1eefe09225ca90dd79efb"><div class="ttname"><a href="namespace_grappa.html#a10cafc5a51b1eefe09225ca90dd79efb">Grappa::walltime</a></div><div class="ttdeci">double walltime(void)</div><div class="ttdoc">&quot;Universal&quot; wallclock time (works at least for Mac, MTA, and most Linux) </div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00061">common.hpp:61</a></div></div>
<div class="ttc" id="struct_vertex_html_a559eab86c75e9f09d2a43a66621299e0"><div class="ttname"><a href="struct_vertex.html#a559eab86c75e9f09d2a43a66621299e0">Vertex::num_children</a></div><div class="ttdeci">index_t num_children</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00036">tree.hpp:36</a></div></div>
<div class="ttc" id="struct_vertex_html_ab0e93fe247b5054a22ef04c5e754ea32"><div class="ttname"><a href="struct_vertex.html#ab0e93fe247b5054a22ef04c5e754ea32">Vertex::id</a></div><div class="ttdeci">index_t id</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00035">tree.hpp:35</a></div></div>
<div class="ttc" id="group___containers_html_gac5a9df86f535f81420219d9dfcab5584"><div class="ttname"><a href="group___containers.html#gac5a9df86f535f81420219d9dfcab5584">Grappa::memset</a></div><div class="ttdeci">void memset(GlobalAddress&lt; T &gt; base, S value, size_t count)</div><div class="ttdoc">Initialize an array of elements of generic type with a given value. </div><div class="ttdef"><b>Definition:</b> <a href="_array_8hpp_source.html#l00049">Array.hpp:49</a></div></div>
<div class="ttc" id="_global_completion_event_8hpp_html_a3525a4b506b239918f69d5880f19638a"><div class="ttname"><a href="_global_completion_event_8hpp.html#a3525a4b506b239918f69d5880f19638a">target</a></div><div class="ttdeci">Core target</div><div class="ttdef"><b>Definition:</b> <a href="_global_completion_event_8hpp_source.html#l00086">GlobalCompletionEvent.hpp:86</a></div></div>
<div class="ttc" id="group___communication_html_gaff2afcac6058e98ea3c6151f2445702b"><div class="ttname"><a href="group___communication.html#gaff2afcac6058e98ea3c6151f2445702b">Grappa::cores</a></div><div class="ttdeci">Core cores()</div><div class="ttdoc">How many cores are there in this job? </div><div class="ttdef"><b>Definition:</b> <a href="_communicator_8hpp_source.html#l00349">Communicator.hpp:349</a></div></div>
<div class="ttc" id="group___synchronization_html_gad28a884076dc9b8914e694d245b03bf8"><div class="ttname"><a href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">Grappa::spawn</a></div><div class="ttdeci">void spawn(CompletionEvent *ce, TF tf)</div><div class="ttdoc">Spawn Grappa::privateTask and implicitly synchronize with the given CompletionEvent (or GlobalComplet...</div><div class="ttdef"><b>Definition:</b> <a href="_completion_event_8hpp_source.html#l00142">CompletionEvent.hpp:142</a></div></div>
<div class="ttc" id="namespace_grappa_html_ae60d424e890e6dfc18f880b28b168127"><div class="ttname"><a href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">Grappa::finish</a></div><div class="ttdeci">void finish(F f)</div><div class="ttdef"><b>Definition:</b> <a href="_global_completion_event_8hpp_source.html#l00345">GlobalCompletionEvent.hpp:345</a></div></div>
<div class="ttc" id="namespace_grappa_html_a1eb494aa98f6908538488b8d98cdbc7aabd0ca6be53b0f3d2886fd53fcb52574e"><div class="ttname"><a href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7aabd0ca6be53b0f3d2886fd53fcb52574e">Grappa::SyncMode::Blocking</a></div></div>
<div class="ttc" id="namespace_grappa_html_af7b60a124d5f39fd448e002fa2a3e11f"><div class="ttname"><a href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">Grappa::init</a></div><div class="ttdeci">void init(int *argc_p, char **argv_p[], int64_t size)</div><div class="ttdoc">Initialize Grappa. </div><div class="ttdef"><b>Definition:</b> <a href="_grappa_8cpp_source.html#l00506">Grappa.cpp:506</a></div></div>
<div class="ttc" id="_context_switch_rate__bench_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="_context_switch_rate__bench_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="_context_switch_rate__bench_8cpp_source.html#l00070">ContextSwitchRate_bench.cpp:70</a></div></div>
<div class="ttc" id="group___communication_html_ga1b0faf3e8ee3ef69117c14c5d4547396"><div class="ttname"><a href="group___communication.html#ga1b0faf3e8ee3ef69117c14c5d4547396">Grappa::message</a></div><div class="ttdeci">Message&lt; T &gt; message(Core dest, T t)</div><div class="ttdoc">Construct a message allocated on the stack. </div><div class="ttdef"><b>Definition:</b> <a href="_message_8hpp_source.html#l00343">Message.hpp:343</a></div></div>
<div class="ttc" id="group___communication_html_ga9d165cbd8cbb54ce375f342722022a91"><div class="ttname"><a href="group___communication.html#ga9d165cbd8cbb54ce375f342722022a91">Grappa::mycore</a></div><div class="ttdeci">Core mycore()</div><div class="ttdoc">What&#39;s my core ID in this job? </div><div class="ttdef"><b>Definition:</b> <a href="_communicator_8hpp_source.html#l00352">Communicator.hpp:352</a></div></div>
<div class="ttc" id="group___collectives_html_gac74a2d7ffb5b36ec6833ebfc54c16841"><div class="ttname"><a href="group___collectives.html#gac74a2d7ffb5b36ec6833ebfc54c16841">Grappa::on_all_cores</a></div><div class="ttdeci">void on_all_cores(F work)</div><div class="ttdoc">Spawn a private task on each core, block until all complete. </div><div class="ttdef"><b>Definition:</b> <a href="_collective_8hpp_source.html#l00109">Collective.hpp:109</a></div></div>
<div class="ttc" id="_collective_8hpp_html_a230e982687661a48480a16098f36e533"><div class="ttname"><a href="_collective_8hpp.html#a230e982687661a48480a16098f36e533">collective_add</a></div><div class="ttdeci">T collective_add(const T &amp;a, const T &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_collective_8hpp_source.html#l00046">Collective.hpp:46</a></div></div>
<div class="ttc" id="group___memory_html_ga55c522130968fe1140cb8505dc9eac1a"><div class="ttname"><a href="group___memory.html#ga55c522130968fe1140cb8505dc9eac1a">make_global</a></div><div class="ttdeci">GlobalAddress&lt; T &gt; make_global(T *t, Core n=Grappa::mycore())</div><div class="ttdoc">return a 2d global pointer to a local pointer on a particular core </div><div class="ttdef"><b>Definition:</b> <a href="_addressing_8hpp_source.html#l00424">Addressing.hpp:424</a></div></div>
<div class="ttc" id="namespace_grappa_html_a1eb494aa98f6908538488b8d98cdbc7a"><div class="ttname"><a href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">Grappa::SyncMode</a></div><div class="ttdeci">SyncMode</div><div class="ttdoc">Specify whether an operation blocks until complete, or returns &quot;immediately&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00057">common.hpp:57</a></div></div>
<div class="ttc" id="namespace_grappa_1_1impl_html_a3a32c8a9e7384af43f3ec125411d2f99"><div class="ttname"><a href="namespace_grappa_1_1impl.html#a3a32c8a9e7384af43f3ec125411d2f99">Grappa::impl::forall_here</a></div><div class="ttdeci">void forall_here(int64_t start, int64_t iters, F loop_body, void(F::*mf)(int64_t, int64_t) const)</div><div class="ttdef"><b>Definition:</b> <a href="_parallel_loop_8hpp_source.html#l00121">ParallelLoop.hpp:121</a></div></div>
<div class="ttc" id="_grappa_8hpp_html_a8c30457bc353d908bcd82438bc27c9ef"><div class="ttname"><a href="_grappa_8hpp.html#a8c30457bc353d908bcd82438bc27c9ef">unbound</a></div><div class="ttdeci">#define unbound</div><div class="ttdoc">Specify non-default behavior: stealable tasks. </div><div class="ttdef"><b>Definition:</b> <a href="_grappa_8hpp_source.html#l00080">Grappa.hpp:80</a></div></div>
<div class="ttc" id="tree_8hpp_html_aca24a3c0ef851eaa0da0cd75cde76eab"><div class="ttname"><a href="tree_8hpp.html#aca24a3c0ef851eaa0da0cd75cde76eab">create_tree</a></div><div class="ttdeci">GlobalAddress&lt; Vertex &gt; create_tree(size_t _num_vertices)</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00061">tree.hpp:61</a></div></div>
<div class="ttc" id="namespace_grappa_html_a1c507e85501aa5a02cee9c2dae4912fe"><div class="ttname"><a href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">Grappa::forall</a></div><div class="ttdeci">void forall(GlobalAddress&lt; GlobalHashMap&lt; T, V &gt;&gt; self, F visit)</div><div class="ttdef"><b>Definition:</b> <a href="_global_hash_map_8hpp_source.html#l00267">GlobalHashMap.hpp:267</a></div></div>
<div class="ttc" id="_communicator_8hpp_html_a3a0af41b6e127e7f96781ce84aa9d40e"><div class="ttname"><a href="_communicator_8hpp.html#a3a0af41b6e127e7f96781ce84aa9d40e">Core</a></div><div class="ttdeci">int16_t Core</div><div class="ttdoc">Type for Core and Locale IDs. </div><div class="ttdef"><b>Definition:</b> <a href="_communicator_8hpp_source.html#l00071">Communicator.hpp:71</a></div></div>
<div class="ttc" id="group___synchronization_html_gad0f5511c9e55d6d5cd3add33bf00d527"><div class="ttname"><a href="group___synchronization.html#gad0f5511c9e55d6d5cd3add33bf00d527">Grappa::complete</a></div><div class="ttdeci">void complete(CompletionType *ce)</div><div class="ttdoc">Match ConditionVariable-style function call. </div><div class="ttdef"><b>Definition:</b> <a href="_completion_event_8hpp_source.html#l00096">CompletionEvent.hpp:96</a></div></div>
<div class="ttc" id="namespace_grappa_html_a71018ba89353f75b1a4159b95295b801"><div class="ttname"><a href="namespace_grappa.html#a71018ba89353f75b1a4159b95295b801">Grappa::invoke</a></div><div class="ttdeci">void invoke(SuspendedDelegate *c)</div><div class="ttdef"><b>Definition:</b> <a href="_suspended_delegate_8hpp_source.html#l00085">SuspendedDelegate.hpp:85</a></div></div>
<div class="ttc" id="group___delegates_html_ga9314cb77365ab51d6fe4772c611921bc"><div class="ttname"><a href="group___delegates.html#ga9314cb77365ab51d6fe4772c611921bc">Grappa::delegate::call</a></div><div class="ttdeci">auto call(Core dest, F f) -&gt; AUTO_INVOKE((impl::Specializer&lt; S, C, F &gt;::call(dest, f,&amp;F::operator())))</div></div>
<div class="ttc" id="class_global_address_html"><div class="ttname"><a href="class_global_address.html">GlobalAddress</a></div><div class="ttdoc">Global address class. </div><div class="ttdef"><b>Definition:</b> <a href="_addressing_8hpp_source.html#l00099">Addressing.hpp:99</a></div></div>
<div class="ttc" id="struct_data_html"><div class="ttname"><a href="struct_data.html">Data</a></div><div class="ttdef"><b>Definition:</b> <a href="addressing__symmetric_8cpp_source.html#l00010">addressing_symmetric.cpp:10</a></div></div>
<div class="ttc" id="namespace_grappa_html_ac6ade1fca200baa13c39fe78703897b9"><div class="ttname"><a href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">Grappa::TaskMode</a></div><div class="ttdeci">TaskMode</div><div class="ttdoc">Specify whether tasks are bound to the core they&#39;re spawned on, or if they can be load-balanced (via ...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00054">common.hpp:54</a></div></div>
<div class="ttc" id="struct_vertex_html_a701b309f0cf071ab3169295906a00b34"><div class="ttname"><a href="struct_vertex.html#a701b309f0cf071ab3169295906a00b34">Vertex::first_child</a></div><div class="ttdeci">GlobalAddress&lt; Vertex &gt; first_child</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00037">tree.hpp:37</a></div></div>
<div class="ttc" id="namespace_grappa_html_a0b29dfddf8e0c5d3c912565a0b1db6d0"><div class="ttname"><a href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">Grappa::global_free</a></div><div class="ttdeci">void global_free(GlobalAddress&lt; T &gt; address)</div><div class="ttdoc">Free memory allocated from global shared heap. </div><div class="ttdef"><b>Definition:</b> <a href="_global_allocator_8hpp_source.html#l00147">GlobalAllocator.hpp:147</a></div></div>
<div class="ttc" id="struct_vertex_html_a05cd99acff53a6e8eced70cf58c93424"><div class="ttname"><a href="struct_vertex.html#a05cd99acff53a6e8eced70cf58c93424">Vertex::color</a></div><div class="ttdeci">long color</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00039">tree.hpp:39</a></div></div>
<div class="ttc" id="search2_8cpp_html_ac9e7613948b8bd919d4205d430183a00"><div class="ttname"><a href="search2_8cpp.html#ac9e7613948b8bd919d4205d430183a00">results</a></div><div class="ttdeci">GlobalAddress&lt; GlobalVector&lt; index_t &gt; &gt; results</div><div class="ttdef"><b>Definition:</b> <a href="search2_8cpp_source.html#l00004">search2.cpp:4</a></div></div>
<div class="ttc" id="group___delegates_html_ga13cb46277cd2bf8c03ae12952afdcaf4"><div class="ttname"><a href="group___delegates.html#ga13cb46277cd2bf8c03ae12952afdcaf4">Grappa::delegate::write</a></div><div class="ttdeci">void write(GlobalAddress&lt; T &gt; target, U value)</div><div class="ttdoc">Blocking remote write. </div><div class="ttdef"><b>Definition:</b> <a href="_delegate_8hpp_source.html#l00253">Delegate.hpp:253</a></div></div>
<div class="ttc" id="struct_vertex_html"><div class="ttname"><a href="struct_vertex.html">Vertex</a></div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00034">tree.hpp:34</a></div></div>
<div class="ttc" id="group___synchronization_html_ga0e49ee2c2ae50e793e427b0fcfa842f9"><div class="ttname"><a href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">Grappa::wait</a></div><div class="ttdeci">void wait(GlobalAddress&lt; ConditionVariable &gt; m)</div><div class="ttdoc">Proxy for remote ConditionVariable manipulation. </div><div class="ttdef"><b>Definition:</b> <a href="_condition_variable_8hpp_source.html#l00039">ConditionVariable.hpp:39</a></div></div>
<div class="ttc" id="_global_completion_event_8hpp_html_ad946b8f6f79a9ee73d674f86a7964100"><div class="ttname"><a href="_global_completion_event_8hpp.html#ad946b8f6f79a9ee73d674f86a7964100">size</a></div><div class="ttdeci">virtual const size_t size() const </div><div class="ttdoc">Unserialized message size. </div><div class="ttdef"><b>Definition:</b> <a href="_global_completion_event_8hpp_source.html#l00110">GlobalCompletionEvent.hpp:110</a></div></div>
<div class="ttc" id="namespace_grappa_html_a661c56b3ed1f67b0ae3228e67a738380"><div class="ttname"><a href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380">Grappa::finalize</a></div><div class="ttdeci">int finalize()</div><div class="ttdoc">Clean up Grappa. </div><div class="ttdef"><b>Definition:</b> <a href="_grappa_8cpp_source.html#l00511">Grappa.cpp:511</a></div></div>
<div class="ttc" id="group___delegates_html_gac416433d8fcb845ba67ef1f3509c1a45"><div class="ttname"><a href="group___delegates.html#gac416433d8fcb845ba67ef1f3509c1a45">Grappa::delegate::fetch_and_add</a></div><div class="ttdeci">T fetch_and_add(GlobalAddress&lt; T &gt; target, U inc)</div><div class="ttdoc">Fetch the value at target, increment the value stored there with inc and return the original value to...</div><div class="ttdef"><b>Definition:</b> <a href="_delegate_8hpp_source.html#l00270">Delegate.hpp:270</a></div></div>
<div class="ttc" id="group___collectives_html_ga11c2394bdfc6a31779ddc418cf790b73"><div class="ttname"><a href="group___collectives.html#ga11c2394bdfc6a31779ddc418cf790b73">Grappa::reduce</a></div><div class="ttdeci">T reduce(T *global_ptr)</div><div class="ttdoc">Called from a single task (usually user_main), reduces values from all cores onto the calling node...</div><div class="ttdef"><b>Definition:</b> <a href="_collective_8hpp_source.html#l00293">Collective.hpp:293</a></div></div>
<div class="ttc" id="group___utility_html_gaca7bf381c18a5f791155eb129c726fe7"><div class="ttname"><a href="group___utility.html#gaca7bf381c18a5f791155eb129c726fe7">GRAPPA_DEFINE_METRIC</a></div><div class="ttdeci">#define GRAPPA_DEFINE_METRIC(type, name, arg1)</div><div class="ttdoc">Define a new Grappa Metric. </div><div class="ttdef"><b>Definition:</b> <a href="_metrics_8hpp_source.html#l00102">Metrics.hpp:102</a></div></div>
<div class="ttc" id="search1_8cpp_html_adeea7b0e098ad4d29e4c12c41cb73e43"><div class="ttname"><a href="search1_8cpp.html#adeea7b0e098ad4d29e4c12c41cb73e43">gce</a></div><div class="ttdeci">GlobalCompletionEvent gce</div><div class="ttdef"><b>Definition:</b> <a href="search1_8cpp_source.html#l00007">search1.cpp:7</a></div></div>
<div class="ttc" id="group___tasking_html_ga1fa04570855ffc3d360a5264f950eb24"><div class="ttname"><a href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">Grappa::run</a></div><div class="ttdeci">void run(FP fp)</div><div class="ttdef"><b>Definition:</b> <a href="_tasking_8hpp_source.html#l00182">Tasking.hpp:182</a></div></div>
<div class="ttc" id="search1_8cpp_html_acf3ae97c6a67edaad03d52ba3bb2aba4"><div class="ttname"><a href="search1_8cpp.html#acf3ae97c6a67edaad03d52ba3bb2aba4">search_color</a></div><div class="ttdeci">long search_color</div><div class="ttdef"><b>Definition:</b> <a href="search1_8cpp_source.html#l00005">search1.cpp:5</a></div></div>
<div class="ttc" id="_grappa_8hpp_html"><div class="ttname"><a href="_grappa_8hpp.html">Grappa.hpp</a></div></div>
<div class="ttc" id="search1_8cpp_html_a9139bae75747a04b3bf2c3e7cfd10bc2"><div class="ttname"><a href="search1_8cpp.html#a9139bae75747a04b3bf2c3e7cfd10bc2">count</a></div><div class="ttdeci">int64_t count</div><div class="ttdef"><b>Definition:</b> <a href="search1_8cpp_source.html#l00003">search1.cpp:3</a></div></div>
<div class="ttc" id="namespace_grappa_html_a1eb494aa98f6908538488b8d98cdbc7aa24aa4117da86c41684ad25742832dfa6"><div class="ttname"><a href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7aa24aa4117da86c41684ad25742832dfa6">Grappa::SyncMode::Async</a></div></div>
<div class="ttc" id="group___delegates_html_gacad9d4d47cb0c49667bfdd59c604c100"><div class="ttname"><a href="group___delegates.html#gacad9d4d47cb0c49667bfdd59c604c100">Grappa::delegate::increment</a></div><div class="ttdeci">void increment(GlobalAddress&lt; T &gt; target, U inc)</div><div class="ttdef"><b>Definition:</b> <a href="_delegate_8hpp_source.html#l00425">Delegate.hpp:425</a></div></div>
<div class="ttc" id="_aggregator_8cpp_html_a20f1ffc9506ce3245f5e40eed824724b"><div class="ttname"><a href="_aggregator_8cpp.html#a20f1ffc9506ce3245f5e40eed824724b">DEFINE_int64</a></div><div class="ttdeci">DEFINE_int64(aggregator_autoflush_ticks, 50000,&quot;number of ticks to wait before autoflushing aggregated active messages&quot;)</div></div>
<div class="ttc" id="group___delegates_html_ga3e28e8fd8f1a8a22beca2301cb24a639"><div class="ttname"><a href="group___delegates.html#ga3e28e8fd8f1a8a22beca2301cb24a639">Grappa::delegate::read</a></div><div class="ttdeci">T read(GlobalAddress&lt; T &gt; target)</div><div class="ttdoc">Read the value (potentially remote) at the given GlobalAddress, blocks the calling task until round-t...</div><div class="ttdef"><b>Definition:</b> <a href="_delegate_8hpp_source.html#l00230">Delegate.hpp:230</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorial_8md.html">tutorial.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
